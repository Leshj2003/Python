# GIL全局解释器锁

## 1.何为全局解释器锁

全局解释器锁：每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。下图是python代码的执行过程，当我们使用python命令行去运行python代码的时候cpython解释器会将python代码编译成二进制并运行。这个时候会运行一个主进程而一个主进程只会有一个python解释器，这就导致了python线程同一时刻只有一个可以执行代码。

```flow
st=>start: python代码
op=>operation: python解释器
sub1=>subroutine: CPU
st->op->sub1
```

## 2.实验验证

demo:单线程占满cpu

```python
while True:
    pass
```

在单核cpu的计算机下运行这个程序，会发现它会占满整个cup。

demo:2线程死循环

```
import treading

def test():
    while True:
        pass
t1 = treading.Tread(target=test)
ti.start()

# 主进程死循环
while True:
    pass
```

在双核cpu的计算机下运行这个程序，会发现它只会占两个cup的各自一半。这就说明线程并未占用全部cpu，一个进程只能够独享一个解释器，多个线程之间不能使用多个解释器。

当主线程运行时他会将解释器锁住独占解释器，当运行阻塞时会释放解释器锁，此时子线程会使用解释器并将其锁定，直到它遇到阻塞时。

线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100



## 3.解决方法

### <1>.换解释器：

Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。

### <2>.使用多进程

Python使用多进程是可以利用多核的CPU资源的。

### <3>.子线程调用其他语言编写的动态库

子线程使例如c语言编写，直接调用的话就会使用c语言本身的编译器，不会独占cpytho解释器



## 4.为什么多线程比单线程性能有提升？

因为遇到IO阻塞会自动释放GIL锁

